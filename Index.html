<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clickable Curved Text</title>

  <!-- React + Babel CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body {
      background: #000;
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      color: white;
      text-align: center;
    }

    .curved-loop-jacket {
      min-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
    }

    .curved-loop-svg {
      user-select: none;
      width: 100%;
      aspect-ratio: 100 / 12;
      overflow: visible;
      display: block;
      font-size: 8rem;
      fill: #ffffff;
      text-transform: uppercase;
    }

    .word {
      pointer-events: auto;
      cursor: pointer;
      transition: fill 0.2s;
    }

    .word:hover {
      fill: #00eaff;
    }

    #selectedWordBox {
      margin-top: 40px;
      font-size: 2rem;
      font-weight: bold;
      color: #00eaff;
    }
  </style>
</head>
<body>

  <div id="root"></div>

<script type="text/babel">

const { useRef, useEffect, useState, useMemo, useId } = React;

const CurvedLoop = ({
  marqueeText = "",
  speed = 2,
  curveAmount = 400,
  direction = "left",
  interactive = true,
  onWordSelected // NEW PROP
}) => {

  const words = marqueeText.trim().split(/\s+/);
  const unitText = words.join(" ") + " ";
  const repeatedText = useMemo(()=> unitText.repeat(20), [marqueeText]);

  const measureRef = useRef(null);
  const textPathRef = useRef(null);
  const [spacing, setSpacing] = useState(0);
  const [offset, setOffset] = useState(0);

  const uid = useId();
  const pathId = `curve-${uid}`;
  const pathD = `M-100,40 Q500,${40 + curveAmount} 1540,40`;

  const dragRef = useRef(false);
  const lastXRef = useRef(0);
  const velRef = useRef(0);
  const dirRef = useRef(direction);

  useEffect(() => {
    if (measureRef.current) {
      setSpacing(measureRef.current.getComputedTextLength());
    }
  }, [unitText]);

  useEffect(() => {
    if (!spacing || !textPathRef.current) return;
    textPathRef.current.setAttribute("startOffset", -spacing);
    setOffset(-spacing);
  }, [spacing]);

  useEffect(() => {
    let frame;
    const animate = () => {
      if (!dragRef.current && textPathRef.current) {
        const delta = dirRef.current === "right" ? speed : -speed;
        let newOffset = offset + delta;

        if (newOffset <= -spacing) newOffset += spacing;
        if (newOffset > 0) newOffset -= spacing;

        setOffset(newOffset);
        textPathRef.current.setAttribute("startOffset", newOffset);
      }
      frame = requestAnimationFrame(animate);
    };
    frame = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(frame);
  }, [offset, spacing, speed]);

  const handlePointerDown = (e) => {
    if (!interactive) return;
    dragRef.current = true;
    lastXRef.current = e.clientX;
    velRef.current = 0;
    e.target.setPointerCapture(e.pointerId);
  };

  const handlePointerMove = (e) => {
    if (!interactive || !dragRef.current || !textPathRef.current) return;

    const dx = e.clientX - lastXRef.current;
    lastXRef.current = e.clientX;
    velRef.current = dx;

    let newOffset = offset + dx;

    if (newOffset <= -spacing) newOffset += spacing;
    if (newOffset > 0) newOffset -= spacing;

    setOffset(newOffset);
    textPathRef.current.setAttribute("startOffset", newOffset);
  };

  const stopDrag = () => {
    dragRef.current = false;
    dirRef.current = velRef.current > 0 ? "right" : "left";
  };

  const handleWordClick = (word) => {
    console.log("Clicked word:", word);
    onWordSelected(word); // Update parent
  };

  return (
    <div
      className="curved-loop-jacket"
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={stopDrag}
      onPointerLeave={stopDrag}
    >
      <svg className="curved-loop-svg" viewBox="0 0 1440 120">
        <text ref={measureRef} style={{ visibility: "hidden" }}>{unitText}</text>

        <defs>
          <path id={pathId} d={pathD} fill="none" stroke="transparent" />
        </defs>

        <text>
          <textPath ref={textPathRef} href={`#${pathId}`}>
            {repeatedText.split(" ").map((word, i) => (
              <tspan 
                key={i} 
                className="word" 
                onClick={() => handleWordClick(word)}
              >
                {word + " "}
              </tspan>
            ))}
          </textPath>
        </text>
      </svg>
    </div>
  );
};

function App() {
  const [currentWord, setCurrentWord] = useState("");

  return (
    <>
      <CurvedLoop 
        marqueeText="Welcome to React Bits Creative Animation Test Demo"
        onWordSelected={setCurrentWord}
      />

      <div id="selectedWordBox">
        Current word: {currentWord ? currentWord : "None"}
      </div>
    </>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);

</script>
</body>
</html>
